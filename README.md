
# Hybrid Spatio-Temporal Model Checker
**Paper Title:** Hybrid Spatio-Temporal Logic for Automotive Applications: Modeling and Model-Checking 

**Authors:** Radu-Florin Tulcan, Rose Bohrer, Yoàv Montacute, Kevin Zhou, Yusuke Kawamoto, and Ichiro Hasuo

## Description
This project is the implementation of the model checker for the _Hybrid Spatio-Temporal Logic for
Automotive Safety_. This file contains metadata about the implementation, information about the project structure,
and about the parsable syntax of our logic. It also contains information about how the different versions of our model checker
can be used, as well as some insights about the experiments conducted, which highlight the capabilities of our logic and model
checker.

## Logic Syntax
The syntax used here follows the one from the paper. The table below consists of the operators permitted and the corresponding symbols parsable by the model checker:


| Operator               | Symbols  | Operator            | Symbols |
|------------------------|----------|---------------------|---------|
| Logical Truth          | ⊤ or 1   | Spatial Left        | Left    |
| Logical Falsity        | ⊥ or 0   | Spatial Right       | Right   |
| Logical Negation       | ¬ or !   | Temporal Next       | X       |
| Logical And            | ∧ or &   | Temporal Eventually | F       |
| Logical Or             | \|       | Temporal Always     | G       |
| Logical Implication    | → or ->  | Temporal Until      | U       |
| Logical Bi-implication | ↔ or <-> | At Operator         | @       |
| Spatial Front          | Front    | Bind Operator       | ↓ or :  |
| Spatial Back           | Back     |


Furthermore, propositions can be any string generated by the regular expression `[a-y][a-y0-9_]*`.
Names for nominals can be generated using the following regular expression `z[0-9_]*`.

**Precedence relation:** The operators satisfy the following precedence relation: `↔ << → << | << ∧ << U << ¬, Left, Right, Back, Front, X, F, G, @, ↓`.


## Project Metadata
Python v3.9 has been used for the development of this project.

## Folder structure
The project contains multiple folders. Their contents are summarized in the list below:

- `checkers/baseline_version`: contains the implementation of the baseline model checker
- `checker/optimized_version`: contains the implementation of the two optimized versions of our model checker
- `formula_types`: contains all necessary classes and methods for the various operators of our logic and their evaluation
- `parsers`: includes parser code for the different components of our language
- `ExperimentRunner.py`: contains the code for the experiments included in the paper and detailed [below](#experiments).


## Usage
The checkers can be run using the following command:
```
docker run --rm paper-artifact:latest python ExperimentRunner.py [-h] [--quick | --all] [--road_length ROAD_LENGTH] [--road_width ROAD_WIDTH] [--prop PROPS] [--nom NOMS]
                           [--assumptions ASSUMPTIONS] [--conclusions CONCLUSIONS] [--max_trace_length MAX_TRACE_LENGTH] [--show_traces {0,1}]      
                           [--checker {optimized,baseline,motion}]
```
We allow three modes of operation:
- ``quick``: this mode runs the test suit with the smaller test cases, totalling a run-time of around 20 minutes
- ``all``: this mode runs all test cases included in the paper, with an approximate run-time of around 3.5 - 4 hours
- custom mode: this mode allows custom experimentation of our model checkers using the following parameters
  - ``road_length`` (positive number): the length of the grid structure
  - ``road_width`` (positive number): the width of the grid structure
  - ``prop`` (string): a proposition used in the custom formulas. This argument can occur multiple times.
  - ``assumptions`` (string): a path to a file containing the formulas used as assumptions, where each formula is written in a separate line. For convenient usage, the artifact contains a file ``assumptions.txt`` that can be used as input.
  - ``conclusions`` (string): a path to a file containing the formulas used as conclusion, where each formula is written in a separate line. For convenient usage, the artifact contains a file ``assumptions.txt`` that can be used as input.
  - ``max_trace_length`` (positive number): maximal length of traces that the checker should evaluate the formulas against
  - ``show_traces`` (0/1): whether the satisfying traces should be displayed in the commandline or not
  - ``checker`` (optimized/baseline/motion): the checker version

**Example:** 
```
docker run --rm paper-artifact:latest python ExperimentRunner.py \
    --road_length 2 \
    --road_width 3 \
    --prop a \
    --prop b \
    --assumptions assumptions.txt \
    --conclusions conclusions.txt \
    --max_trace_length 3 \
    --show_traces 1 \
    --checker optimized 
```

## Experiments
The file `ExperimentRunner.py` contains the experiments conducted for our paper. This section will go over the experiments in detail.

### One Lane Follow

This scenario has been implemented in the function `one_lane_follow_test`. In this scenario test that one vehicle can safely follow another in the same lane.  `z0` is SV, `z1` is POV1, `z2` is a temporary variable. In this scenario we assume the following:
 
-  `@z0 !(Back 1)`: SV is initially at the start of the lane
-  `G (@z1 ↓z2 ((! X 1) | X @z1  (z2 | Back z2)))`: POV always moves forward or stays put
-  `G (@z0 ↓z2 ((! X 1) | X (@z0 ((!z1 & Back z2 ) | (z2 & Front z1) ))))`: SV always moves forward if safe, stays put if POV immediately ahead

The property we want to check is, whether these two vehicles collide. It can be expressed by `G(!(@z0 z1))`.

**_Usefulness_**: This is a minimal, practical scenario, that can be easily scaled as needed.

### Safe Intersection with Priority
This scenario models a 4-way intersection where one road has priority over the other, so that only one vehicle needs to stop. We consider an (nxn) grid where the POV vehicle moves left-to-right without stopping.
The SV vehicle moves back to front and stops if POV is on track to collide. Here, `z0` is SV, `z1` is POV, `z2` is a temporary variable.
For this scenario we assume the following:

- `@z1 !(Left 1)`: POV starts somewhere on the left border
- `@z0 !(Back 1)`: SV starts somewhere on the bottom border
- `G (@z1 ↓z2 ((! X 1)| X @z1 (Left z2)))`: POV always moves left-to-right
- `G (@z0 ↓z2 ((! X 1)| X @z0 ((!z1 & Back z2) | (z2 & Front z1) )))`: moves bottom-to-top except it stops to avoid the other vehicle

In this scenario we also check for non-collision, expressed by `G(!(@z0 z1))`.

**_Usefulness_**: Since the grid scales quadratically, new, larger test cases can be generated easily. Furthermore, crossing an intersection allows us
to demonstrate a higher level of generality of our logic.

### Safe Passing
In this section we consider the following scenario: On a two-lane road, POV moves forward at uneven speed. 
Initially SV moves forward at even speed. If it is ever directly behind POV, it swerves to left, 
then drives at high speed to overtake POV, swerves right, then drives normally. Concretely, the scenario is
divided into the following steps:
1. move forward initially (duration of >=0 timesteps)
2. swerve left (duration of 1 timestep)
3. drive forward fast (duration of >0 timesteps)
4. swerve right (duration of 1 timestep)
5. go forward at normal speed (duration is all remaining timesteps)

Furthermore, in this example, `z0` is SV, `z1` is POV, and `z2` a temporary variable. For modelling it, we used the following formulas:
- `G(@z1 !(Right 1))`: POV starts anywhere in right lane, stays in right lane
- `@z0 !(Right 1)`:  SV starts in the back
- `@z0 !(Back 1)`: SV starts in the right lane
- `G (@z1 ↓z2 ((! X 1) | X @z1  (z2 | Back z2)))`: POV moves forward or stays in place

Moreover, the following formula encodes the 5-step behavior described above:
`(φ1 U (φ2 & ((! X 1) | X (φ3 & ((! X 1) | X (φ3 U (φ4 & ((! X 1) | X G (φ5)))))))))`
with:
- `φ1:= (@z0 ↓z2 ((! X 1) | X @z0 (Back z2)))`: SV initially moves forward
- `φ2:= (@z0 ↓z2 ((Front z1) & ((! X 1)| X (@z0 (Back (Right z2))))))`: SV swerves left
- `φ3:= (@z0 ↓z2 ((! X 1)| X @z0 (Back (Back z2))))`: SV drives twice as fast
- `φ4:= (@z0 ↓z2 ((! X 1)| X @z0 (Back (Left z2))))`: SV swerves right when safe
- `φ5:= (@z0 ↓z2 ((! X 1) | X @z0 (Back z2)))`: SV drives normally
Note the pattern  P & X (P Until Q) is used to ensure Step 3 runs for at least one timestep

In this scenario we also check for non-collision, expressed by `G(!(@z0 z1))`.

**Usefulness:** This scenario represents a stress-test for the Until operator. This non-trivial example
Helps demonstrate the value of optimizing one vehicle when the other clearly cannot be optimized
(though we have other tests which demonstrate that same point).

### Join Platoon
In this scenario, a platoon of POV cars are all traveling at constant speed. The SV is trying to join the platoon. 
It can join the platoon by switching lanes if the resulting position is both behind a car of the platoon and is safe.
Here, `z0` is SV and `z1-zn` are the n POVs. In the following, we write `|i in [1..n] P(i)` for an n-ary disjunction.
We assume the following formulas:
- `φ1:= @z0 !(Right 1)`: SV starts in the right lane
- `φ2:= G(@zi !(Left 1)) (for i in [1,n])`: POVs are always in left lane
- `φ3:= G(@z0 ↓z ((! X 1) | (X @z0((Back z)|`: SV, go forward any time, or
          `((|i in [1,n] Front zi)&(Right z)&(!(|i in [1,n] zi))))))` switch lane if safe
- `φ4:= G(@zi ↓z ((! X 1) | X (@zi (Back z)))) (for i in [1,n])`: Platoon cars move forward
And the conclusion is:
- `φ5:= G(@z0 !(|i in [1,n] zi))` Collision avoidance


**Usefulness:** Most other tests only scale the road while keeping the number of vehicles and the formulas the same. 
This test scales the number of vehicles and the size of the formulas, which allows us to evaluate a different aspect of scalability compared to the other test cases.

_Subtle note:_ We allow multiple cars in the platoon to have the same position as each other. We choose to see this as a feature instead of a bug, because it's equivalent
to testing all platoons of size *up to N* instead of size *exactly N*, e.g., if all cars in a 5-car platoon are in the same position, it functions as a 1-car platoon.
