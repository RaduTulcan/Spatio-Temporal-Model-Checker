
# Spatio-Temporal Model Checker


This project is the implementation of the model checker for the _Hybrid Spatio-Temporal Logic for
Automotive Safety_. This file contains metadata about the implementation, information about the project structure,
and about the parsable syntax of our logic. It also contains information about how the different versions of our model checker
can be used, as well as some insights about the experiments conducted, which highlight the capabilities of our logic and model
checker.

## Project Metadata
Python v3.9 has been used for the development of this project.

## Logic Syntax
The syntax used here follows the one from the paper. The table below consists of the operators permitted and the corresponding symbols parsable by the model checker:


| Operator               | Symbols | Operator            | Symbols |
|------------------------|---------|---------------------|---------|
| Logical Truth          | ⊤ or 1  | Spatial Left        | Left    |
| Logical Falsity        | ⊥ or 0  | Spatial Right       | Right   |
| Logical Negation       | ¬ or !  | Temporal Next       | X       |
| Logical And            | ∧ or &  | Temporal Eventually | F       |
| Logical Or             | \|      | Temporal Always     | G       |
| Logical Implication    | → or -> | Temporal Until      | U       |
| Logical Bi-implication | <->     | At Operator         | @       |
| Spatial Front          | Front   | Bind Operator       | ↓ or :  |
| Spatial Back           | Back    |


Furthermore, propositions can be any string generated by the regular expression `[a-y][a-y0-9_]*`.
Names for nominals can be generated using the following regular expression `z[0-9_]*`.


## Folder structure
The project contains multiple folders. Their contents are summarized in the list below:

- `checkers/baseline_version`: contains the implementation of the baseline model checker
- `checker/optimized_version`: contains the implementation of the two optimized versions of our model checker
- `formula_types`: contains all necessary classes and methods for the various operators of our logic and their evaluation
- `parsers`: includes parser code for the different components of our language
- `ExperimentRunner.py`: contains the code for the experiments included in the paper and detailed [below](#experiments).


## Usage
Our model checker (and all its versions) can be run in two ways. The simplest way is to run the
already implemented experiments in `ExperimentRunner.py`. This file runs the pre-defined scenarios
on all three versions of the model checker.

On the other hand, the model checker can be run with custom formulas. To do so, consider the following 
examples, which illustrate how our model checker can be used.


### 1) Evaluate a formula with respect to a given trace and spatial point 


```python
from checkers.SpatioTemporalEvaluatorUtils import generate_trace_from_spec
from formula_types.HybridSpatioTemporalFormula import HybridSpatioTemporalFormula
from parsers.HybridSpatioTemporalFormulaParser import HybridSpatioTemporalParser, tokenize

# list of propositions
propositions = []

# list of nominals
nominals = ["z0", "z1"]

# list of assumptions (restrict the traces and points of interest)
assumptions: list[str] = ["@z1 !(Left 1)", "@z0 !(Back 1)"]

# list of conclusions (formulas to be checked at all traces and spatial
# points in which the assumptions hold)
conclusions: list[str] = ["G(!(@z0 z1))"]

# size of the spatial grid graph (n x m)
grid_size: tuple[int, int] = (3, 3)

# specification spatio-temporal trace
# indexes of the matrix represent indexes for the spatial points
# the strings at (i,j) represent the temporal evolution of that
# spatial point
#
# Example:
# [                                     [                        [
#  ["a;b" ";"],   represents the trace    { "a": [(0,0)], ----->    "a" : [],
#  ["b;"  ";"]                            "b": [(0,1)] }            "b": [(0,0)]
# ]                                     ]                        ]
trace_spec: list[list[str]] = [
    [";;", ",;;z1,", ";;"],
    [";;", ";z1;", ";;z0"],
    [";;", "z1;;", "z0;z0;"]
]

# transform the input grid format into a trace
trace: list[dict] = generate_trace_from_spec(trace_spec, grid_size)

# spatial point in the grid
point: tuple[int, int] = (0, 1)

# conjunction of assumptions and conclusion
input_formula_string: str = "&".join([*("(" + x + ")" for x in conclusions), *("(" + x + ")" for x in assumptions)])

# parse the input formula
parsed_formula: HybridSpatioTemporalFormula = HybridSpatioTemporalParser(tokenize(input_formula_string)).parse()

# retrieve result
print("The formula ", parsed_formula, " evaluates to ", parsed_formula.evaluate(trace, point, grid_size), " at point ", point,
      "\n")
```

### 2) Evaluate formula with respect to a trace and retrieve the spatial points where the given formula holds (baseline only)

```python
from checkers.SpatioTemporalEvaluatorUtils import generate_trace_from_spec, satisfying_points
from formula_types.HybridSpatioTemporalFormula import HybridSpatioTemporalFormula
from parsers.HybridSpatioTemporalFormulaParser import HybridSpatioTemporalParser, tokenize

# list of propositions
propositions = []

# list of nominals
nominals = ["z0", "z1"]

# list of assumptions (restrict the traces and points of interest)
assumptions: list[str] = ["@z1 !(Left 1)", "@z0 !(Back 1)"]

# list of conclusions (formulas to be checked at all traces and spatial
# points in which the assumptions hold)
conclusions: list[str] = ["G(!(@z0 z1))"]

# size of the spatial grid graph (n x m)
grid_size: tuple[int, int] = (3, 3)

# specification spatio-temporal trace
# indexes of the matrix represent indexes for the spatial points
# the strings at (i,j) represent the temporal evolution of that
# spatial point
#
# Example:
# [                                     [                        [
#  ["a;b" ";"],   represents the trace    { "a": [(0,0)], ----->    "a" : [],
#  ["b;"  ";"]                            "b": [(0,1)] }            "b": [(0,0)]
# ]                                     ]                        ]
trace_spec: list[list[str]] = [
    [";;", ",;;z1,", ";;"],
    [";;", ";z1;", ";;z0"],
    [";;", "z1;;", "z0;z0;"]
]

# transform the input grid format into a trace
trace: list[dict] = generate_trace_from_spec(trace_spec, grid_size)

# conjunction of assumptions and conclusion
input_formula_string: str = "&".join([*("(" + x + ")" for x in conclusions), *("(" + x + ")" for x in assumptions)])

# parse the input formula
parsed_formula: HybridSpatioTemporalFormula = HybridSpatioTemporalParser(tokenize(input_formula_string)).parse()

# retrieve result
print("The formula ", parsed_formula, " is true at the following spatial points w.r.t. the given trace:",
      satisfying_points(parsed_formula, trace, grid_size), '\n')
```

### 3) Retrieve traces and the spatial points inside the trace in which the given formula holds

```python
from checkers.baseline_version.evaluator_baseline.BaselineSpatioTemporalEvaluator import evaluate as evaluate_baseline
from checkers.optimized_version.evaluator_optimized.OptimizedSpatioTemporalEvaluator1 import evaluate as evaluate_optimized1
from checkers.optimized_version.evaluator_optimized.OptimizedSpatioTemporalEvaluator2 import evaluate as evaluate_optimized2

# list of propositions
propositions = []

# list of nominals
nominals = ["z0", "z1"]

# list of assumptions (restrict the traces and points of interest)
assumptions: list[str] = ["@z1 !(Left 1)", "@z0 !(Back 1)"]

# list of conclusions (formulas to be checked at all traces and spatial
# points in which the assumptions hold)
conclusions: list[str] = ["G(!(@z0 z1))"]

# size of the spatial grid graph (n x m)
grid_size: tuple[int, int] = (3, 3)

# call the baseline model checker
evaluate_baseline(propositions, nominals, assumptions, conclusions, grid_size, 2, True)

# call the optimized model checker (v1)
evaluate_optimized1(propositions, nominals, assumptions, conclusions, grid_size, 2, True)

# call the optimized model checker (v2)
evaluate_optimized2(propositions, nominals, assumptions, conclusions, grid_size, 2, True)
```


## Experiments
The file `ExperimentRunner.py` contains the experiments conducted for our paper. This section will go over the experiments in detail.

### One Lane Follow

This scenario has been implemented in the function `one_lane_follow_test`. In this scenario test that one vehicle can safely follow another in the same lane.  `z0` is SV, `z1` is POV1, `z2` is a temporary variable. In this scenario we assume the following:
 
-  `@z0 !(Back 1)`: SV is initially at the start of the lane
-  `G (@z1 ↓z2 ((! X 1) | X @z1  (z2 | Back z2)))`: POV always moves forward or stays put
-  `G (@z0 ↓z2 ((! X 1) | X (@z0 ((!z1 & Back z2 ) | (z2 & Front z1) ))))`: SV always moves forward if safe, stays put if POV immediately ahead

The property we want to check is, whether these two vehicles collide. It can be expressed by `G(!(@z0 z1))`.

**_Usefulness_**: This is a minimal, practical scenario, that can be easily scaled as needed.

### Safe Intersection with Priority
This scenario models a 4-way intersection where one road has priority over the other, so that only one vehicle needs to stop. We consider an (nxn) grid where the POV vehicle moves left-to-right without stopping.
The SV vehicle moves back to front and stops if POV is on track to collide. Here, `z0` is SV, `z1` is POV, `z2` is a temporary variable.
For this scenario we assume the following:

- `@z1 !(Left 1)`: POV starts somewhere on the left border
- `@z0 !(Back 1)`: SV starts somewhere on the bottom border
- `G (@z1 ↓z2 ((! X 1)| X @z1 (Left z2)))`: POV always moves left-to-right
- `G (@z0 ↓z2 ((! X 1)| X @z0 ((!z1 & Back z2) | (z2 & Front z1) )))`: moves bottom-to-top except it stops to avoid the other vehicle

In this scenario we also check for non-collision, expressed by `G(!(@z0 z1))`.

**_Usefulness_**: Since the grid scales quadratically, new, larger test cases can be generated easily. Furthermore, crossing an intersection allows us
to demonstrate a higher level of generality of our logic.