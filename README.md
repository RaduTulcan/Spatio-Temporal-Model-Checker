
# Spatio-Temporal Model Checker


This project is the implementation of the spatio-temporal model checker for the logic [LOGIC_NAME].

## Project Metadata
Python version: 3.9

## Logic Syntax
The syntax used here follows the one from the paper. The table below consists of the operators permitted and the corresponding symbols parsable by the model checker:

| Operator    | Symbols |
| -------- |---------|
| Logical Truth | ⊤/1     |
| Logical Falsity| ⊥/0     |
| Logical Negation    | ¬/!     |
| Logical And    | ∧/&     |
| Logical Or    | \|      |
| Logical Implication    | →/->    |
| Logical Bi-implication    | <->     |
| Spatial Front    | Front   |
| Spatial Back    | Back    |
| Spatial Left    | Left    |
| Spatial Right    | Right   |
| Temporal Next | X       |
| Temporal Eventually | F       |
| Temporal Always | G       |
| Temporal Until | U       |
 | At Operator | @       |
| Bind Operator | ↓/:     |

Furthermore, propositions can be any string generated by the regular expression `[a-y][a-y0-9_]*`.
Names for nominals can be generated using the following regular expression `z[0-9_]*`.


## Folder structure



## Usage/Examples
There are two ways in which both versions of the model checker can be run. On one hand, we have prepared for both versions
pre-defined test cases to evaluate performance. These tests can be found in ``baseline_version/BaselineEvaluatorTest.py`` (for the baseline version)
and in ``optimized_version/OptimizedEvaluatorTest.py`` (for the optimized version).

On the other hand, you can run the model checker with your own formulas. Consider the following examples:

### 1) Evaluate a formula with respect to a given trace and spatial point (baseline version only)

```python
from baseline_version.evaluator_baseline.SpatioTemporalEvaluator import generate_trace_from_spec
from HybridSpatioTemporalFormula import HybridSpatioTemporalFormula
from baseline_version.parsers_baseline.HybridSpatioTemporalFormulaParser import tokenize, HybridSpatioTemporalParser

# list of propositions
propositions = []

# list of nominals
nominals = ["z", "z2", "z3"]

# list of assumptions (restrict the traces and points of interest)
assumptions: list[str] = []

# list of conclusions (formulas to be checked at all traces and spatial
# points in which the assumptions hold)
conclusions: list[str] = ["@z  :z2 ((@z3  ↓z2 z3) & @z2 z)"]

# size of the spatial grid graph (n x m)
grid_size: tuple[int, int] = (3, 3)

# specification spatio-temporal trace
# indexes of the matrix represent indexes for the spatial points
# the strings at (i,j) represent the temporal evolution of that
# spatial point
#
# Example:
# [                                     [                   [
#  ["a;b" ";"],   represents the trace    ["a" ""], ----->    ["b" ""],
#  ["b;"  ";"]                            ["b" ""]            [""  ""]
# ]                                     ]                   ]
trace_spec: list[list[str]] = [
    [";;", "z,b;z;a,z", ";;"],
    [";;", ";a;b", ";;"],
    [";;", "a;b;", "b;;"]
]

# transform the input grid format into a trace
trace: list[list[list[list]]] = generate_trace_from_spec(trace_spec, grid_size)

# spatial point in the grid
point: tuple[int, int] = (0, 1)

# conjunction of assumptions and conclusion
input_formula_string: str = "&".join([*("(" + x + ")" for x in conclusions), *("(" + x + ")" for x in assumptions)])

# parse the input formula
parsed_formula: HybridSpatioTemporalFormula = HybridSpatioTemporalParser(tokenize(input_formula_string)).parse()

# retrieve result
print("The formula ", parsed_formula, " evaluates to ", parsed_formula.evaluate(trace, point), " at point ", point, "\n")
```

### 2) Evaluate formula with respect to a trace and retrieve the spatial points where the given formula holds (baseline only)

```python
from baseline_version.evaluator_baseline.SpatioTemporalEvaluator import generate_trace_from_spec, satisfying_points
from HybridSpatioTemporalFormula import HybridSpatioTemporalFormula
from baseline_version.parsers_baseline.HybridSpatioTemporalFormulaParser import tokenize, HybridSpatioTemporalParser

# list of propositions
propositions = []

# list of nominals
nominals = ["z", "z2", "z3"]

# list of assumptions (restrict the traces and points of interest)
assumptions: list[str] = []

# list of conclusions (formulas to be checked at all traces and spatial
# points in which the assumptions hold)
conclusions: list[str] = ["@z  :z2 ((@z3  ↓z2 z3) & @z2 z)"]

# size of the spatial grid graph (n x m)
grid_size: tuple[int, int] = (3, 3)

# specification spatio-temporal trace
# indexes of the matrix represent indexes for the spatial points
# the strings at (i,j) represent the temporal evolution of that
# spatial point
#
# Example:
# [                                     [                   [
#  ["a;b" ";"],   represents the trace    ["a" ""], ----->    ["b" ""],
#  ["b;"  ";"]                            ["b" ""]            [""  ""]
# ]                                     ]                   ]
trace_spec: list[list[str]] = [
    [";;", "z,b;z;a,z", ";;"],
    [";;", ";a;b", ";;"],
    [";;", "a;b;", "b;;"]
]

# transform the input grid format into a trace
trace: list[list[list[list]]] = generate_trace_from_spec(trace_spec, grid_size)

# conjunction of assumptions and conclusion
input_formula_string: str = "&".join([*("(" + x + ")" for x in conclusions), *("(" + x + ")" for x in assumptions)])

# parse the input formula
parsed_formula: HybridSpatioTemporalFormula = HybridSpatioTemporalParser(tokenize(input_formula_string)).parse()

# retrieve result
print("The formula ", parsed_formula, " is true at the following spatial points w.r.t. the given trace:", satisfying_points(parsed_formula, trace, grid_size), '\n')
```

### 3) Retrieve traces and the spatial points inside the trace in which the given formula holds (baseline)
```python
from baseline_version.evaluator_baseline.SpatioTemporalEvaluator import satisfying_trace_points
from HybridSpatioTemporalFormula import HybridSpatioTemporalFormula
from baseline_version.parsers_baseline.HybridSpatioTemporalFormulaParser import tokenize, HybridSpatioTemporalParser

# list of propositions
propositions = []

# list of nominals
nominals = ["z", "z2", "z3"]

# list of assumptions (restrict the traces and points of interest)
assumptions: list[str] = []

# list of conclusions (formulas to be checked at all traces and spatial
# points in which the assumptions hold)
conclusions: list[str] = ["@z  :z2 ((@z3  ↓z2 z3) & @z2 z)"]

# size of the spatial grid graph (n x m)
grid_size: tuple[int, int] = (3, 3)

# conjunction of assumptions and conclusion
input_formula_string: str = "&".join([*("(" + x + ")" for x in conclusions), *("(" + x + ")" for x in assumptions)])

# parse the input formula
parsed_formula: HybridSpatioTemporalFormula = HybridSpatioTemporalParser(tokenize(input_formula_string)).parse()

# retrieve result
satisfying_trace_points(propositions, nominals, parsed_formula, grid_size, 2, False)
```
### 4) Retrieve traces and the spatial points inside the trace in which the given formula holds (optimize)

```python
from optimized_version.evaluator_optimized.Radu_SpatioTemporalEvaluator import satisfying_trace_points
from HybridSpatioTemporalFormula import HybridSpatioTemporalFormula
from optimized_version.parsers_optimized.HybridSpatioTemporalFormulaParser import tokenize, HybridSpatioTemporalParser

# list of propositions
propositions = []

# list of nominals
nominals = ["z", "z2", "z3"]

# list of assumptions (restrict the traces and points of interest)
assumptions: list[str] = []

# list of conclusions (formulas to be checked at all traces and spatial
# points in which the assumptions hold)
conclusions: list[str] = ["@z  :z2 ((@z3  ↓z2 z3) & @z2 z)"]

# size of the spatial grid graph (n x m)
grid_size: tuple[int, int] = (3, 3)

# only allow assumptions that are either purely classical and hybrid, and contains only operator G with argument
# a purely classical or hybrid formula
state_assumptions = []

for a in assumptions:
    if "X" not in a and "U" not in a and "F" not in a:
        state_assumptions.append(a)

parsed_state_assumptions = [HybridSpatioTemporalParser(tokenize(assumption)).parse() for assumption in state_assumptions]

# conjunction of assumptions and conclusion
input_formula_string: str = "&".join([*("(" + x + ")" for x in conclusions), *("(" + x + ")" for x in set(assumptions).difference(state_assumptions))])

# parse the input formula
parsed_formula: HybridSpatioTemporalFormula = HybridSpatioTemporalParser(tokenize(input_formula_string)).parse()

# compute the satisfying trace-point pairs
satisfying_trace_points(propositions, nominals, parsed_formula, parsed_state_assumptions, grid_size, 2, False)
```