
# Spatio-Temporal Model Checker


This project is the implementation of the model checker for the _Hybrid Spatio-Temporal Logic for
Automotive Safety_. This file contains metadata about the implementation, information about the project structure,
and about the parsable syntax of our logic. It also contains information about how the different versions of our model checker
can be used, as well as some insights about the experiments conducted, which highlight the capabilities of our logic and model
checker.

## Project Metadata
Python v3.9 has been used for the development of this project.

## Logic Syntax
The syntax used here follows the one from the paper. The table below consists of the operators permitted and the corresponding symbols parsable by the model checker:


| Operator               | Symbols  | Operator            | Symbols |
|------------------------|----------|---------------------|---------|
| Logical Truth          | ⊤ or 1   | Spatial Left        | Left    |
| Logical Falsity        | ⊥ or 0   | Spatial Right       | Right   |
| Logical Negation       | ¬ or !   | Temporal Next       | X       |
| Logical And            | ∧ or &   | Temporal Eventually | F       |
| Logical Or             | \|       | Temporal Always     | G       |
| Logical Implication    | → or ->  | Temporal Until      | U       |
| Logical Bi-implication | ↔ or <-> | At Operator         | @       |
| Spatial Front          | Front    | Bind Operator       | ↓ or :  |
| Spatial Back           | Back     |


Furthermore, propositions can be any string generated by the regular expression `[a-y][a-y0-9_]*`.
Names for nominals can be generated using the following regular expression `z[0-9_]*`.

**Precedence relation:** The operators satisfy the following precedence relation: `↔ << → << | << ∧ << U << ¬, Left, Right, Back, Front, X, F, G, @, ↓`.


## Folder structure
The project contains multiple folders. Their contents are summarized in the list below:

- `checkers/baseline_version`: contains the implementation of the baseline model checker
- `checker/optimized_version`: contains the implementation of the two optimized versions of our model checker
- `formula_types`: contains all necessary classes and methods for the various operators of our logic and their evaluation
- `parsers`: includes parser code for the different components of our language
- `ExperimentRunner.py`: contains the code for the experiments included in the paper and detailed [below](#experiments).


## Usage
Our model checker (and all its versions) can be run in two ways. The simplest way is to run the
already implemented experiments in `ExperimentRunner.py`. This file runs the pre-defined scenarios
on all three versions of the model checker.

On the other hand, the model checker can be run with custom formulas. To do so, consider the following 
examples, which illustrate how our model checker can be used.


### 1) Evaluate a formula with respect to a given trace and spatial point 


```python
from checkers.SpatioTemporalEvaluatorUtils import generate_trace_from_spec
from formula_types.HybridSpatioTemporalFormula import HybridSpatioTemporalFormula
from parsers.HybridSpatioTemporalFormulaParser import HybridSpatioTemporalParser, tokenize

# list of propositions
propositions = []

# list of nominals
nominals = ["z0", "z1"]

# list of assumptions (restrict the traces and points of interest)
assumptions: list[str] = ["@z1 !(Left 1)", "@z0 !(Back 1)"]

# list of conclusions (formulas to be checked at all traces and spatial
# points in which the assumptions hold)
conclusions: list[str] = ["G(!(@z0 z1))"]

# size of the spatial grid graph (n x m)
grid_size: tuple[int, int] = (3, 3)

# specification spatio-temporal trace
# indexes of the matrix represent indexes for the spatial points
# the strings at (i,j) represent the temporal evolution of that
# spatial point
#
# Example:
# [                                     [                        [
#  ["a;b" ";"],   represents the trace    { "a": [(0,0)], ----->    "a" : [],
#  ["b;"  ";"]                            "b": [(0,1)] }            "b": [(0,0)]
# ]                                     ]                        ]
trace_spec: list[list[str]] = [
    [";;", ",;;z1,", ";;"],
    [";;", ";z1;", ";;z0"],
    [";;", "z1;;", "z0;z0;"]
]

# transform the input grid format into a trace
trace: list[dict] = generate_trace_from_spec(trace_spec, grid_size)

# spatial point in the grid
point: tuple[int, int] = (0, 1)

# conjunction of assumptions and conclusion
input_formula_string: str = "&".join([*("(" + x + ")" for x in conclusions), *("(" + x + ")" for x in assumptions)])

# parse the input formula
parsed_formula: HybridSpatioTemporalFormula = HybridSpatioTemporalParser(tokenize(input_formula_string)).parse()

# retrieve result
print("The formula ", parsed_formula, " evaluates to ", parsed_formula.evaluate(trace, point, grid_size), " at point ", point,
      "\n")
```

### 2) Evaluate formula with respect to a trace and retrieve the spatial points where the given formula holds (baseline only)

```python
from checkers.SpatioTemporalEvaluatorUtils import generate_trace_from_spec, satisfying_points
from formula_types.HybridSpatioTemporalFormula import HybridSpatioTemporalFormula
from parsers.HybridSpatioTemporalFormulaParser import HybridSpatioTemporalParser, tokenize

# list of propositions
propositions = []

# list of nominals
nominals = ["z0", "z1"]

# list of assumptions (restrict the traces and points of interest)
assumptions: list[str] = ["@z1 !(Left 1)", "@z0 !(Back 1)"]

# list of conclusions (formulas to be checked at all traces and spatial
# points in which the assumptions hold)
conclusions: list[str] = ["G(!(@z0 z1))"]

# size of the spatial grid graph (n x m)
grid_size: tuple[int, int] = (3, 3)

# specification spatio-temporal trace
# indexes of the matrix represent indexes for the spatial points
# the strings at (i,j) represent the temporal evolution of that
# spatial point
#
# Example:
# [                                     [                        [
#  ["a;b" ";"],   represents the trace    { "a": [(0,0)], ----->    "a" : [],
#  ["b;"  ";"]                            "b": [(0,1)] }            "b": [(0,0)]
# ]                                     ]                        ]
trace_spec: list[list[str]] = [
    [";;", ",;;z1,", ";;"],
    [";;", ";z1;", ";;z0"],
    [";;", "z1;;", "z0;z0;"]
]

# transform the input grid format into a trace
trace: list[dict] = generate_trace_from_spec(trace_spec, grid_size)

# conjunction of assumptions and conclusion
input_formula_string: str = "&".join([*("(" + x + ")" for x in conclusions), *("(" + x + ")" for x in assumptions)])

# parse the input formula
parsed_formula: HybridSpatioTemporalFormula = HybridSpatioTemporalParser(tokenize(input_formula_string)).parse()

# retrieve result
print("The formula ", parsed_formula, " is true at the following spatial points w.r.t. the given trace:",
      satisfying_points(parsed_formula, trace, grid_size), '\n')
```

### 3) Retrieve traces and the spatial points inside the trace in which the given formula holds

```python
from checkers.baseline_version.evaluator_baseline.BaselineSpatioTemporalEvaluator import evaluate as evaluate_baseline
from checkers.optimized_version.evaluator_optimized.OptimizedSpatioTemporalEvaluator1 import evaluate as evaluate_optimized1
from checkers.optimized_version.evaluator_optimized.OptimizedSpatioTemporalEvaluator2 import evaluate as evaluate_optimized2

# list of propositions
propositions = []

# list of nominals
nominals = ["z0", "z1"]

# list of assumptions (restrict the traces and points of interest)
assumptions: list[str] = ["@z1 !(Left 1)", "@z0 !(Back 1)"]

# list of conclusions (formulas to be checked at all traces and spatial
# points in which the assumptions hold)
conclusions: list[str] = ["G(!(@z0 z1))"]

# size of the spatial grid graph (n x m)
grid_size: tuple[int, int] = (3, 3)

# call the baseline model checker
evaluate_baseline(propositions, nominals, assumptions, conclusions, grid_size, 2, True)

# call the optimized model checker (v1)
evaluate_optimized1(propositions, nominals, assumptions, conclusions, grid_size, 2, True)

# call the optimized model checker (v2)
evaluate_optimized2(propositions, nominals, assumptions, conclusions, grid_size, 2, True)
```


## Experiments
The file `ExperimentRunner.py` contains the experiments conducted for our paper. This section will go over the experiments in detail.

### One Lane Follow

This scenario has been implemented in the function `one_lane_follow_test`. In this scenario test that one vehicle can safely follow another in the same lane.  `z0` is SV, `z1` is POV1, `z2` is a temporary variable. In this scenario we assume the following:
 
-  `@z0 !(Back 1)`: SV is initially at the start of the lane
-  `G (@z1 ↓z2 ((! X 1) | X @z1  (z2 | Back z2)))`: POV always moves forward or stays put
-  `G (@z0 ↓z2 ((! X 1) | X (@z0 ((!z1 & Back z2 ) | (z2 & Front z1) ))))`: SV always moves forward if safe, stays put if POV immediately ahead

The property we want to check is, whether these two vehicles collide. It can be expressed by `G(!(@z0 z1))`.

**_Usefulness_**: This is a minimal, practical scenario, that can be easily scaled as needed.

### Safe Intersection with Priority
This scenario models a 4-way intersection where one road has priority over the other, so that only one vehicle needs to stop. We consider an (nxn) grid where the POV vehicle moves left-to-right without stopping.
The SV vehicle moves back to front and stops if POV is on track to collide. Here, `z0` is SV, `z1` is POV, `z2` is a temporary variable.
For this scenario we assume the following:

- `@z1 !(Left 1)`: POV starts somewhere on the left border
- `@z0 !(Back 1)`: SV starts somewhere on the bottom border
- `G (@z1 ↓z2 ((! X 1)| X @z1 (Left z2)))`: POV always moves left-to-right
- `G (@z0 ↓z2 ((! X 1)| X @z0 ((!z1 & Back z2) | (z2 & Front z1) )))`: moves bottom-to-top except it stops to avoid the other vehicle

In this scenario we also check for non-collision, expressed by `G(!(@z0 z1))`.

**_Usefulness_**: Since the grid scales quadratically, new, larger test cases can be generated easily. Furthermore, crossing an intersection allows us
to demonstrate a higher level of generality of our logic.

### Safe Passing
In this section we consider the following scenario: On a two-lane road, POV moves forward at uneven speed. 
Initially SV moves forward at even speed. If it is ever directly behind POV, it swerves to left, 
then drives at high speed to overtake POV, swerves right, then drives normally. Concretely, the scenario is
divided into the following steps:
1. move forward initially (duration of >=0 timesteps)
2. swerve left (duration of 1 timestep)
3. drive forward fast (duration of >0 timesteps)
4. swerve right (duration of 1 timestep)
5. go forward at normal speed (duration is all remaining timesteps)

Furthermore, in this example, `z0` is SV, `z1` is POV, and `z2` a temporary variable. For modelling it, we used the following formulas:
- `G(@z1 !(Right 1))`: POV starts anywhere in right lane, stays in right lane
- `@z0 !(Right 1)`:  SV starts in the back
- `@z0 !(Back 1)`: SV starts in the right lane
- `G (@z1 ↓z2 ((! X 1) | X @z1  (z2 | Back z2)))`: POV moves forward or stays in place

Moreover, the following formula encodes the 5-step behavior described above:
`(φ1 U (φ2 & ((! X 1) | X (φ3 & ((! X 1) | X (φ3 U (φ4 & ((! X 1) | X G (φ5)))))))))`
with:
- `φ1:= (@z0 ↓z2 ((! X 1) | X @z0 (Back z2)))`: SV initially moves forward
- `φ2:= (@z0 ↓z2 ((Front z1) & ((! X 1)| X (@z0 (Back (Right z2))))))`: SV swerves left
- `φ3:= (@z0 ↓z2 ((! X 1)| X @z0 (Back (Back z2))))`: SV drives twice as fast
- `φ4:= (@z0 ↓z2 ((! X 1)| X @z0 (Back (Left z2))))`: SV swerves right when safe
- `φ5:= (@z0 ↓z2 ((! X 1) | X @z0 (Back z2)))`: SV drives normally
Note the pattern  P & X (P Until Q) is used to ensure Step 3 runs for at least one timestep

In this scenario we also check for non-collision, expressed by `G(!(@z0 z1))`.

**Usefulness:** This scenario represents a stress-test for the Until operator. This non-trivial example
Helps demonstrate the value of optimizing one vehicle when the other clearly cannot be optimized
(though we have other tests which demonstrate that same point).

# Join Platoon
In this scenario, a platoon of POV cars are all traveling at constant speed. The SV is trying to join the platoon. 
It can join the platoon by switching lanes if the resulting position is both behind a car of the platoon and is safe.
Here, `z0` is SV and `z1-zn` are the n POVs. We used the following formulas for modelling 
this scenario:
- TODO


**Usefulness:** Most other tests only scale the road while keeping the number of vehicles and the formulas the same. 
This test scales the number of vehicles and the size of the formulas, which allows us to evaluate a different aspect of scalability compared to the other test cases.

_Subtle note:_ We allow multiple cars in the platoon to have the same position as each other. We choose to see this as a feature instead of a bug, because it's equivalent
to testing all platoons of size *up to N* instead of size *exactly N*, e.g., if all cars in a 5-car platoon are in the same position, it functions as a 1-car platoon.
